# 05 Skill: Custom Strapi Plugins Integration

**Description:** Rules for parsing and integrating internal `@sklinet` and `@notum-cz` Strapi plugins within Next.js components.

## 1. Rich Text & TinyMCE (`@sklinet/strapi-plugin-tinymce` / `bold-title-editor`)
When the CMS sends WYSIWYG content (HTML strings generated by TinyMCE or Bold Title Editor), you **MUST NOT** use React's `dangerouslySetInnerHTML` directly in generic UI blocks.
- **Rule:** Always wrap the HTML string in the company's `<RichText content={content} />` primitive.
- The `RichText` component safely parses the HTML, handles internal routing replacements, and applies global typography formatting.

Example:
```tsx
import { RichText } from '../../primitives/RichText/RichText';

// Inside your block
<div className="text-wrapper">
    <RichText content={data.description} />
</div>
```
- If you need to extract raw text (e.g. for a summary or meta tag), use the `getTextFromRichText(content)` utility.

## 2. Dynamic Forms (`@sklinet/strapi-plugin-form-builder`)
Strapi allows admins to construct forms dynamically. When you map a `form-block` to the frontend:
- **Rule:** Do not build static input fields manually if the data comes from the Form Builder.
- Map the data to the `<FormBuilder>` organism (`src/app/components/organisms/FormBuilder/FormBuilder.tsx`).
- Form submission is handled via `axios.post('/api/submit-form', formData)`. Do not write new API fetching logic for forms.

## 3. Backend Plugins
When modifying the `cms/` repository:
- `@notum-cz/strapi-plugin-record-locking`: This is a backend CMS safety plugin. Do not attempt to modify it or bypass it in lifecycle hooks.
- `@sklinet/strapi-plugin-publisher`: Manages publish states.

## 4. Blocks vs. Floors
- Components registered as **Blocks** (`ComponentBlockHeroBlock`) belong in `src/app/blocks/`.
- Components registered as **Floors** (`ComponentFloorRichTextFloor`) belong in rich-text iterators, typically rendered by the `FloorBuilder` organism. Do not treat Floors like top-level Page Blocks.

## 5. Elasticsearch Reindexing
Strapi content changes are synced to an Elasticsearch cluster via frontend webhooks.
- **Webhook Handler:** `frontend/src/app/api/elastic/indexItem/route.ts`
- **Rule:** When you add a new Strapi Content Type or a Block relation that needs to be searchable or listed, you **MUST** add a `case` in the switch statement of `indexItem/route.ts` and handle the reindexing logic (using `fetchMany` and `addToCollection`).

## 6. Structured Data (JSON-LD) SEO
When the CMS provides Structured Data (e.g. from Global SEO or Page SEO settings):
- **Rule:** Never render JSON-LD directly via a standard React component passing arbitrary objects.
- **Rule:** In Next.js App Router, Structured Data **MUST** be rendered using Next.js `<Script>` tags with the stringified JSON and `strategy="beforeInteractive"`.

Example:
```tsx
import Script from 'next/script';

{structuredData && (
    <Script
        id="structured-data"
        type="application/ld+json"
        strategy="beforeInteractive"
        dangerouslySetInnerHTML={{ __html: JSON.stringify(structuredData) }}
    />
)}
```

### 6.2 Next.js `generateMetadata`
When constructing the `<title>` element inside Next.js `generateMetadata` from Strapi SEO data:
- **Rule:** Do not blindly pass `title: metaData.metaTitle` alone.
- You **MUST** concatenate the title with the global suffix: `` const metaTitle = `${metaData.metaTitle}${metaData.suffix}`; `` and pass the calculated `metaTitle` to the custom metadata object.

## 7. Cookiebot Injection (`[COOKIE_DECLARATION]`)
The company utilizes a specific regex/string-replacement pattern for embedding GDPR Cookiebot tables.
- **Rule:** Do not write custom React components for Cookiebot GDPR declarations.
- Instead, instruct the content editors to insert the exact string `[COOKIE_DECLARATION]` into a standard WYSIWYG Strapi Rich Text field. The `<RichText>` primitive component automatically detects this string and replaces it with the requisite `<script id="CookieDeclaration">` tag.

## 8. Strapi Lifecycles (`cms/src/index.ts`)
When calculating automatic dates for publishing:
- **Rule:** Do not write frontend or API logic to assign explicit `publishDate` timestamps.
- That logic is strictly controlled by backend lifecycle hooks. In `cms/src/index.ts` within the `beforeCreate`/`beforeUpdate` actions, the application intercepts the request and assigns `data.publishDate = new Date().toISOString()`.
